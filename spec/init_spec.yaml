# Gradual Function Type Checking for Lua 5.1, 5.2 & 5.3
# Copyright (C) 2014-2018 Gary V. Vaughan

before:
  this_module = 'typecheck'

  M = require(this_module)

specify typecheck:
- describe require:
  - it does not perturb the global namespace:
      expect(show_apis {added_to='_G', by='typecheck'}).
         to_equal {}


- describe resulterror:
  - before: |
      preamble = [[
         local typecheck = require 'typecheck'         -- line 2
         function ohnoes(n)                            -- line 3
            typecheck.resulterror('ohnoes', 1, nil, n) -- line 4
         end                                           -- line 5
         function caller(n)                            -- line 6
            local r = ohnoes(n)                        -- line 7
            return 'not a tail call'                   -- line 8
         end                                           -- line 9
      ]]

      f, badarg = init(M, this_module, 'resulterror')

  - context with bad arguments:
    - 'it diagnoses missing argument #1':
        expect(f()).to_raise 'string expected, got no value'
    - 'it diagnoses argument #1 type not string':
        stringy = setmetatable({}, {__tostring = function() end})
        expect(f(nil)).to_raise 'string expected, got nil'
        expect(f(stringy)).not_to_raise 'string expected'
    - 'it diagnoses missing argument #2':
        expect(f 'X').to_raise 'integer expected, got no value'
    - 'it diagnoses argument #2 type not number':
        expect(f('X', nil)).to_raise 'integer expected, got nil'
        expect(f('X', '1')).not_to_raise 'integer expected'
    - 'it diagnoses argument #2 type not integer':
        expect(f('X', 1.0001)).to_raise 'number has no integer representation'
        expect(f('X', '1.0001')).to_raise 'number has no integer representation'
    - 'it diagnoses argument #4 type not number': |
        expect(f('X', 1, 'ohnoes', false)).
           to_raise "bad argument #4 to 'resulterror' (integer expected, got boolean)"
    - 'it diagnoses argument #4 type not integer': |
        expect(f('X', 99999.0, 'ohnoes', 0.99999)).
           to_raise "bad argument #4 to 'resulterror' (number has no integer representation)"

  - it raises a result error: |
      expect(f('myfunc', 1)).to_raise "bad result #1 from 'myfunc'"
  - it supports optional extramsg argument: |
      expect(f('another', 3, 'oh noes')).
         to_raise "bad result #3 from 'another' (oh noes)"

  - context std._debug is not set:
    - before: |
        shamble = [[
           require 'std._debug'(nil)               -- line 1
        ]] .. preamble
    - it blames the call site by default: |
        expect(luaproc(shamble .. [[
           caller()                                -- line 10
        ]])).to_contain_error ':4: bad result'
    - it honors optional call stack level reporting: |
        expect(luaproc(shamble .. [[
           caller(1)                               -- line 10
        ]])).to_contain_error ':4: bad result'
        expect(luaproc(shamble .. [[
           caller(2)                               -- line 10
        ]])).to_contain_error ':7: bad result'
    - it suppresses position information with level 0: |
        expect(luaproc(shamble .. [[
           caller(0)                               -- line 10
        ]])).to_fail_while_matching '^[^:]+: bad result'

  - context std._debug set to false:
    - before: |
        shamble = [[
           require 'std._debug'(false)             -- line 1
        ]] .. preamble
    - it blames the call site by default: |
        expect(luaproc(shamble .. [[
           caller()                                -- line 10
        ]])).to_contain_error ':4: bad result'
    - it honors optional call stack level reporting: |
        expect(luaproc(shamble .. [[
           caller(1)                               -- line 10
        ]])).to_contain_error ':4: bad result'
        expect(luaproc(shamble .. [[
           caller(2)                               -- line 10
        ]])).to_contain_error ':7: bad result'
    - it suppresses position information with level 0: |
        expect(luaproc(shamble .. [[
           caller(0)                               -- line 10
        ]])).to_fail_while_matching '^[^:]+: bad result'

  - context std._debug set to true:
    - before: |
        shamble = [[
           require 'std._debug'(true)              -- line 1
        ]] .. preamble
    - it blames the call site by default: |
        expect(luaproc(shamble .. [[
           caller()                                -- line 10
        ]])).to_contain_error ':4: bad result'
    - it honors optional call stack level reporting: |
        expect(luaproc(shamble .. [[
           caller(1)                               -- line 10
        ]])).to_contain_error ':4: bad result'
        expect(luaproc(shamble .. [[
           caller(2)                               -- line 10
        ]])).to_contain_error ':7: bad result'
    - it suppresses position information with level 0: |
        expect(luaproc(shamble .. [[
           caller(0)                               -- line 10
        ]])).to_fail_while_matching '^[^:]+: bad result'

  - context std._debug argcheck hint is nil:
    - before: |
        shamble = [[
           require 'std._debug'.argcheck = nil     -- line 1
        ]] .. preamble
    - it blames the call site by default: |
        expect(luaproc(shamble .. [[
           caller()                                -- line 10
        ]])).to_contain_error ':4: bad result'
    - it honors optional call stack level reporting: |
        expect(luaproc(shamble .. [[
           caller(1)                               -- line 10
        ]])).to_contain_error ':4: bad result'
        expect(luaproc(shamble .. [[
           caller(2)                               -- line 10
        ]])).to_contain_error ':7: bad result'
    - it suppresses position information with level 0: |
        expect(luaproc(shamble .. [[
           caller(0)                               -- line 10
        ]])).to_fail_while_matching '^[^:]+: bad result'

  - context std._debug argcheck hint is false:
    - before: |
        shamble = [[
           require 'std._debug'.argcheck = false    -- line 1
        ]] .. preamble
    - it blames the call site by default: |
        expect(luaproc(shamble .. [[
           caller()                                -- line 10
        ]])).to_contain_error ':4: bad result'
    - it honors optional call stack level reporting: |
        expect(luaproc(shamble .. [[
           caller(1)                               -- line 10
        ]])).to_contain_error ':4: bad result'
        expect(luaproc(shamble .. [[
           caller(2)                               -- line 10
        ]])).to_contain_error ':7: bad result'
    - it suppresses position information with level 0: |
        expect(luaproc(shamble .. [[
           caller(0)                               -- line 10
        ]])).to_fail_while_matching '^[^:]+: bad result'

  - context std._debug argcheck hint is true:
    - before: |
        shamble = [[
           require 'std._debug'.argcheck = true    -- line 1
        ]] .. preamble
    - it blames the call site by default: |
        expect(luaproc(shamble .. [[
           caller()                                -- line 10
        ]])).to_contain_error ':4: bad result'
    - it honors optional call stack level reporting: |
        expect(luaproc(shamble .. [[
           caller(1)                               -- line 10
        ]])).to_contain_error ':4: bad result'
        expect(luaproc(shamble .. [[
           caller(2)                               -- line 10
        ]])).to_contain_error ':7: bad result'
    - it suppresses position information with level 0: |
        expect(luaproc(shamble .. [[
           caller(0)                               -- line 10
        ]])).to_fail_while_matching '^[^:]+: bad result'


- describe argerror:
  - before: |
      preamble = [[
         local typecheck = require 'typecheck'       -- line 2
         function ohnoes(n)                          -- line 3
            typecheck.argerror('ohnoes', 1, nil, n)  -- line 4
         end                                         -- line 5
         function inner(n)                           -- line 6
            local r = ohnoes(n)                      -- line 7
            return 'not a tail call'                 -- line 8
         end                                         -- line 9
         function caller(n)                          -- line 10
            local r = inner(n)                       -- line 11
            return 'not a tail call'                 -- line 12
         end                                         -- line 13
      ]]

      f, badarg = init(M, this_module, 'argerror')

  - context with bad arguments:
    - 'it diagnoses missing argument #1':
        expect(f()).to_raise 'string expected, got no value'
    - 'it diagnoses argument #1 type not string':
        stringy = setmetatable({}, {__tostring = function() end})
        expect(f(nil)).to_raise 'string expected, got nil'
        expect(f(stringy)).not_to_raise 'string expected'
    - 'it diagnoses missing argument #2':
        expect(f 'X').to_raise 'integer expected, got no value'
    - 'it diagnoses argument #2 type not number':
        expect(f('X', nil)).to_raise 'integer expected, got nil'
        expect(f('X', '1')).not_to_raise 'integer expected'
    - 'it diagnoses argument #2 type not integer':
        expect(f('X', 1.0001)).to_raise 'number has no integer representation'
        expect(f('X', '1.0001')).to_raise 'number has no integer representation'
    - 'it diagnoses argument #4 type not number': |
        expect(f('X', 1, 'ohnoes', false)).
           to_raise "bad argument #4 to 'argerror' (integer expected, got boolean)"
    - 'it diagnoses argument #4 type not integer': |
        expect(f('X', 99999.0, 'ohnoes', 0.99999)).
           to_raise "bad argument #4 to 'argerror' (number has no integer representation)"

  - it raises an argument error: |
      expect(f('myfunc', 1)).to_raise "bad argument #1 to 'myfunc'"
  - it supports optional extramsg argument: |
      expect(f('another', 3, 'oh noes')).
         to_raise "bad argument #3 to 'another' (oh noes)"

  - context std._debug set to nil:
    - before: |
        shamble = [[
           require 'std._debug'(nil)               -- line 1
        ]] .. preamble
    - it blames the call site by default: |
        expect(luaproc(shamble .. [[
           caller()                                -- line 14
        ]])).to_contain_error ':7: bad argument'
    - it honors optional call stack level reporting: |
        expect(luaproc(shamble .. [[
           caller(1)                               -- line 14
        ]])).to_contain_error ':7: bad argument'
        expect(luaproc(shamble .. [[
           caller(2)                               -- line 14
        ]])).to_contain_error ':11: bad argument'
        expect(luaproc(shamble .. [[
           caller(3)                               -- line 14
        ]])).to_contain_error ':14: bad argument'
    - it suppresses position information with level 0: |
        expect(luaproc(shamble .. [[
           caller(0)                               -- line 14
        ]])).to_fail_while_matching '^[^:]+: bad argument'

  - context std._debug set to false:
    - before: |
        shamble = [[
           require 'std._debug'(false)             -- line 1
        ]] .. preamble
    - it blames the call site by default: |
        expect(luaproc(shamble .. [[
           caller()                                -- line 14
        ]])).to_contain_error ':7: bad argument'
    - it honors optional call stack level reporting: |
        expect(luaproc(shamble .. [[
           caller(1)                               -- line 14
        ]])).to_contain_error ':7: bad argument'
        expect(luaproc(shamble .. [[
           caller(2)                               -- line 14
        ]])).to_contain_error ':11: bad argument'
        expect(luaproc(shamble .. [[
           caller(3)                               -- line 14
        ]])).to_contain_error ':14: bad argument'
    - it suppresses position information with level 0: |
        expect(luaproc(shamble .. [[
           caller(0)                               -- line 14
        ]])).to_fail_while_matching '^[^:]+: bad argument'

  - context std._debug set to true:
    - before: |
        shamble = [[
           require 'std._debug'(true)              -- line 1
        ]] .. preamble
    - it blames the call site by default: |
        expect(luaproc(shamble .. [[
           caller()                                -- line 14
        ]])).to_contain_error ':7: bad argument'
    - it honors optional call stack level reporting: |
        expect(luaproc(shamble .. [[
           caller(1)                               -- line 14
        ]])).to_contain_error ':7: bad argument'
        expect(luaproc(shamble .. [[
           caller(2)                               -- line 14
        ]])).to_contain_error ':11: bad argument'
        expect(luaproc(shamble .. [[
           caller(3)                               -- line 14
        ]])).to_contain_error ':14: bad argument'
    - it suppresses position information with level 0: |
        expect(luaproc(shamble .. [[
           caller(0)                               -- line 14
        ]])).to_fail_while_matching '^[^:]+: bad argument'

  - context std._debug argcheck hint is nil:
    - before: |
        shamble = [[
           require 'std._debug'.argcheck = nil     -- line 1
        ]] .. preamble
    - it blames the call site by default: |
        expect(luaproc(shamble .. [[
           caller()                                -- line 14
        ]])).to_contain_error ':7: bad argument'
    - it honors optional call stack level reporting: |
        expect(luaproc(shamble .. [[
           caller(1)                               -- line 14
        ]])).to_contain_error ':7: bad argument'
        expect(luaproc(shamble .. [[
           caller(2)                               -- line 14
        ]])).to_contain_error ':11: bad argument'
        expect(luaproc(shamble .. [[
           caller(3)                               -- line 14
        ]])).to_contain_error ':14: bad argument'
    - it suppresses position information with level 0: |
        expect(luaproc(shamble .. [[
           caller(0)                               -- line 14
        ]])).to_fail_while_matching '^[^:]+: bad argument'

  - context std._debug argcheck hint is false:
    - before: |
        shamble = [[
           require 'std._debug'.argcheck = false    -- line 1
        ]] .. preamble
    - it blames the call site by default: |
        expect(luaproc(shamble .. [[
           caller()                                -- line 14
        ]])).to_contain_error ':7: bad argument'
    - it honors optional call stack level reporting: |
        expect(luaproc(shamble .. [[
           caller(1)                               -- line 14
        ]])).to_contain_error ':7: bad argument'
        expect(luaproc(shamble .. [[
           caller(2)                               -- line 14
        ]])).to_contain_error ':11: bad argument'
        expect(luaproc(shamble .. [[
           caller(3)                               -- line 14
        ]])).to_contain_error ':14: bad argument'
    - it suppresses position information with level 0: |
        expect(luaproc(shamble .. [[
           caller(0)                               -- line 14
        ]])).to_fail_while_matching '^[^:]+: bad argument'

  - context std._debug argcheck hint is true:
    - before: |
        shamble = [[
           require 'std._debug'.argcheck = true    -- line 1
        ]] .. preamble
    - it blames the call site by default: |
        expect(luaproc(shamble .. [[
           caller()                                -- line 14
        ]])).to_contain_error ':7: bad argument'
    - it honors optional call stack level reporting: |
        expect(luaproc(shamble .. [[
           caller(1)                               -- line 14
        ]])).to_contain_error ':7: bad argument'
        expect(luaproc(shamble .. [[
           caller(2)                               -- line 14
        ]])).to_contain_error ':11: bad argument'
        expect(luaproc(shamble .. [[
           caller(3)                               -- line 14
        ]])).to_contain_error ':14: bad argument'
    - it suppresses position information with level 0: |
        expect(luaproc(shamble .. [[
           caller(0)                               -- line 14
        ]])).to_fail_while_matching '^[^:]+: bad argument'


- describe argcheck:
  - before: |
      function clone(self, t)
         return setmetatable(t, getmetatable(self))
      end

      Object = setmetatable({}, {_type = 'Object', __call = clone})
      List = setmetatable({}, { _type = 'List', __call = clone})
      Foo = setmetatable({}, { _type = 'Foo', __call = clone })

      function fn(...)
         return M.argcheck('expect', 1, ...)
      end

      preamble = [[
         local typecheck = require 'typecheck'             -- line 2
         function ohnoes(t, n)                             -- line 3
            typecheck.argcheck('ohnoes', 1, 'table', t, n) -- line 4
         end                                               -- line 5
         function inner(n)                                 -- line 6
            local r = ohnoes('not a table', n)             -- line 7
            return 'not a tail call'                       -- line 8
         end                                               -- line 9
         function caller(n)                                -- line 10
            local r = inner(n)                             -- line 11
            return 'not a tail call'                       -- line 12
         end                                               -- line 13
      ]]

      f, badarg = init(M, this_module, 'argcheck')

  - context std._debug set to nil:
    - before: |
        shamble = [[
           require 'std._debug'(nil)                      -- line 1
        ]] .. preamble
    - it blames the call site by default: |
        expect(luaproc(shamble .. [[
           caller()                                       -- line 14
        ]])).to_contain_error ':7: bad argument'
    - it honors optional call stack level reporting: |
        expect(luaproc(shamble .. [[
           caller(1)                                      -- line 14
        ]])).to_contain_error ':7: bad argument'
        expect(luaproc(shamble .. [[
           caller(2)                                      -- line 14
        ]])).to_contain_error ':11: bad argument'
        expect(luaproc(shamble .. [[
           caller(3)                                      -- line 14
        ]])).to_contain_error ':14: bad argument'

  - context std._debug set to false:
    - before: |
        shamble = [[
           require 'std._debug'(false)                    -- line 1
        ]] .. preamble
    - it is disabled:
        expect(luaproc(shamble .. [[
           caller()                                       -- line 14
        ]])).not_to_contain_error 'bad argument'
        expect(luaproc(shamble .. [[
           caller(1)                                      -- line 14
        ]])).not_to_contain_error 'bad argument'
        expect(luaproc(shamble .. [[
           caller(2)                                      -- line 14
        ]])).not_to_contain_error 'bad argument'
        expect(luaproc(shamble .. [[
           caller(3)                                      -- line 14
        ]])).not_to_contain_error 'bad argument'

  - context std._debug set to true:
    - before: |
        shamble = [[
           require 'std._debug'(true)                     -- line 1
        ]] .. preamble
    - it blames the call site by default: |
        expect(luaproc(shamble .. [[
           caller()                                       -- line 14
        ]])).to_contain_error ':7: bad argument'
    - it honors optional call stack level reporting: |
        expect(luaproc(shamble .. [[
           caller(1)                                      -- line 14
        ]])).to_contain_error ':7: bad argument'
        expect(luaproc(shamble .. [[
           caller(2)                                      -- line 14
        ]])).to_contain_error ':11: bad argument'
        expect(luaproc(shamble .. [[
           caller(3)                                      -- line 14
        ]])).to_contain_error ':14: bad argument'

  - context std._debug argcheck hint is nil:
    - before: |
        shamble = [[
           require 'std._debug'.argcheck = nil            -- line 1
        ]] .. preamble
    - it blames the call site by default: |
        expect(luaproc(shamble .. [[
           caller()                                       -- line 14
        ]])).to_contain_error ':7: bad argument'
    - it honors optional call stack level reporting: |
        expect(luaproc(shamble .. [[
           caller(1)                                      -- line 14
        ]])).to_contain_error ':7: bad argument'
        expect(luaproc(shamble .. [[
           caller(2)                                      -- line 14
        ]])).to_contain_error ':11: bad argument'
        expect(luaproc(shamble .. [[
           caller(3)                                      -- line 14
        ]])).to_contain_error ':14: bad argument'

  - context std._debug argcheck hint is false:
    - before: |
        shamble = [[
           require 'std._debug'.argcheck = false          -- line 1
        ]] .. preamble
    - it is disabled: |
        expect(luaproc(shamble .. [[
           caller()                                       -- line 14
        ]])).not_to_contain_error 'bad argument'
        expect(luaproc(shamble .. [[
           caller(1)                                      -- line 14
        ]])).not_to_contain_error 'bad argument'
        expect(luaproc(shamble .. [[
           caller(2)                                      -- line 14
        ]])).not_to_contain_error 'bad argument'
        expect(luaproc(shamble .. [[
           caller(3)                                      -- line 14
        ]])).not_to_contain_error 'bad argument'

  - context std._debug argcheck hint is true:
    - before: |
        shamble = [[
           require 'std._debug'.argcheck = true           -- line 1
        ]] .. preamble
    - it blames the call site by default: |
        expect(luaproc(shamble .. [[
           caller()                                       -- line 14
        ]])).to_contain_error ':7: bad argument'
    - it honors optional call stack level reporting: |
        expect(luaproc(shamble .. [[
           caller(1)                                      -- line 14
        ]])).to_contain_error ':7: bad argument'
        expect(luaproc(shamble .. [[
           caller(2)                                      -- line 14
        ]])).to_contain_error ':11: bad argument'
        expect(luaproc(shamble .. [[
           caller(3)                                      -- line 14
        ]])).to_contain_error ':14: bad argument'

  - context with primitives:
    - it diagnoses missing types:
        expect(fn('bool', nil)).to_raise 'boolean expected, got no value'
        expect(fn('boolean', nil)).to_raise 'boolean expected, got no value'
        expect(fn('file', nil)).to_raise 'FILE* expected, got no value'
        expect(fn('number', nil)).to_raise 'number expected, got no value'
        expect(fn('string', nil)).to_raise 'string expected, got no value'
        expect(fn('table', nil)).to_raise 'table expected, got no value'
    - it diagnoses mismatched types:
        expect(fn('bool', {0})).to_raise 'boolean expected, got table'
        expect(fn('boolean', {0})).to_raise 'boolean expected, got table'
        expect(fn('file', {0})).to_raise 'FILE* expected, got table'
        expect(fn('number', {0})).to_raise 'number expected, got table'
        expect(fn('string', {0})).to_raise 'string expected, got table'
        expect(fn('table', false)).to_raise 'table expected, got boolean'
    - it matches types:
        expect(fn('bool', true)).not_to_raise 'any error'
        expect(fn('boolean', true)).not_to_raise 'any error'
        expect(fn('file', io.stderr)).not_to_raise 'any error'
        expect(fn('number', 1)).not_to_raise 'any error'
        expect(fn('string', 's')).not_to_raise 'any error'
        expect(fn('table', {})).not_to_raise 'any error'
        expect(fn('table', Object)).not_to_raise 'any error'

  - context with int:
    - it diagnoses missing types:
        expect(fn('int', nil)).to_raise 'int expected, got no value'
    - it diagnoses mismatched types:
        expect(fn('int', false)).to_raise 'int expected, got boolean'
        expect(fn('int', 1.234)).to_raise 'int expected, got number'
        expect(fn('int', 1234e-3)).to_raise 'int expected, got number'
    - it matches types:
        expect(fn('int', 1)).not_to_raise 'any error'
        expect(fn('int', 1.0)).not_to_raise 'any error'
        expect(fn('int', 0x1234)).not_to_raise 'any error'
        expect(fn('int', 1.234e3)).not_to_raise 'any error'
  - context with constant string:
    - it diagnoses missing types:
        expect(fn(':foo', nil)).to_raise ':foo expected, got no value'
    - it diagnoses mismatched types:
        expect(fn(':foo', false)).to_raise ':foo expected, got boolean'
        expect(fn(':foo', ':bar')).to_raise ':foo expected, got :bar'
        expect(fn(':foo', 'foo')).to_raise ':foo expected, got string'
    - it matches types:
        expect(fn(':foo', ':foo')).not_to_raise 'any error'
  - context with callable types:
    - before:
        fctr = setmetatable({0}, {__call = function() end})
    - it diagnoses missing types:
        expect(fn('callable', nil)).to_raise 'callable expected, got no value'
        expect(fn('func', nil)).to_raise 'function expected, got no value'
        expect(fn('functor', nil)).to_raise 'functor expected, got no value'
        expect(fn('function', nil)).to_raise 'function expected, got no value'
    - it diagnoses mismatched types:
        expect(fn('callable', {0})).to_raise 'callable expected, got table'
        expect(fn('func', fctr)).to_raise 'function expected, got functor'
        expect(fn('functor', fn)).to_raise 'functor expected, got function'
        expect(fn('function', fctr)).to_raise 'function expected, got functor'
    - it matches types:
        expect(fn('callable', fn)).not_to_raise 'any error'
        expect(fn('callable', fctr)).not_to_raise 'any error'
        expect(fn('func', function() end)).not_to_raise 'any error'
        expect(fn('functor', fctr)).not_to_raise 'any error'
        expect(fn('function', fn)).not_to_raise 'any error'
  - context with table of homogenous elements:
    - it diagnoses missing types:
        expect(fn('table of boolean', nil)).
           to_raise 'table expected, got no value'
        expect(fn('table of booleans', nil)).
           to_raise 'table expected, got no value'
    - it diagnoses mismatched types:
        expect(fn('table of file', io.stderr)).
           to_raise 'table expected, got file'
        expect(fn('table of files', io.stderr)).
           to_raise 'table expected, got file'
    - it diagnoses mismatched element types:
        expect(fn('table of number', {false})).
           to_raise 'table of numbers expected, got boolean at index 1'
        expect(fn('table of numbers', {1, 2, '3'})).
           to_raise 'table of numbers expected, got string at index 3'
        expect(fn('table of numbers', {a=1, b=2, c='3'})).
           to_raise 'table of numbers expected, got string at index c'
    - it matches types:
        expect(fn('table of string', {})).not_to_raise 'any error'
        expect(fn('table of string', {'foo'})).not_to_raise 'any error'
        expect(fn('table of string', {'f', 'o', 'o'})).not_to_raise 'any error'
        expect(fn('table of string', {b='b', a='a', r='r'})).not_to_raise 'any error'
  - context with non-empty table types:
    - it diagnoses missing types:
        expect(fn('#table', nil)).
           to_raise 'non-empty table expected, got no value'
    - it diagnoses mismatched types:
        expect(fn('#table', false)).
           to_raise 'non-empty table expected, got boolean'
        expect(fn('#table', {})).
           to_raise 'non-empty table expected, got empty table'
    - it matches types:
        expect(fn('#table', {0})).not_to_raise 'any error'
  - context with non-empty table of homogenous elements:
    - it diagnoses missing types:
        expect(fn('#table of boolean', nil)).
           to_raise 'non-empty table expected, got no value'
        expect(fn('#table of booleans', nil)).
           to_raise 'non-empty table expected, got no value'
    - it diagnoses mismatched types:
        expect(fn('#table of file', {})).
           to_raise 'non-empty table expected, got empty table'
        expect(fn('#table of file', io.stderr)).
           to_raise 'non-empty table expected, got file'
    - it diagnoses mismatched element types:
        expect(fn('#table of number', {false})).
           to_raise 'non-empty table of numbers expected, got boolean at index 1'
        expect(fn('#table of numbers', {1, 2, '3'})).
           to_raise 'non-empty table of numbers expected, got string at index 3'
        expect(fn('#table of numbers', {a=1, b=2, c='3'})).
           to_raise 'non-empty table of numbers expected, got string at index c'
    - it matches types:
        expect(fn('#table of string', {'foo'})).not_to_raise 'any error'
        expect(fn('#table of string', {'f', 'o', 'o'})).not_to_raise 'any error'
        expect(fn('#table of string', {b='b', a='a', r='r'})).not_to_raise 'any error'
  - context with list:
    - it diagnonses missing types:
        expect(fn('list', nil)).
           to_raise 'list expected, got no value'
    - it diagnoses mismatched types:
        expect(fn('list', false)).
           to_raise 'list expected, got boolean'
        expect(fn('list', {foo=1})).
           to_raise 'list expected, got table'
        expect(fn('list', Object)).
           to_raise 'list expected, got Object'
    - it matches types:
        expect(fn('list', {})).not_to_raise 'any error'
        expect(fn('list', {1})).not_to_raise 'any error'
  - context with list of homogenous elements:
    - it diagnoses missing types:
        expect(fn('list of boolean', nil)).
           to_raise 'list expected, got no value'
        expect(fn('list of booleans', nil)).
           to_raise 'list expected, got no value'
    - it diagnoses mismatched types:
        expect(fn('list of file', io.stderr)).
           to_raise 'list expected, got file'
        expect(fn('list of files', io.stderr)).
           to_raise 'list expected, got file'
        expect(fn('list of files', {file=io.stderr})).
           to_raise 'list expected, got table'
    - it diagnoses mismatched element types:
        expect(fn('list of number', {false})).
           to_raise 'list of numbers expected, got boolean at index 1'
        expect(fn('list of numbers', {1, 2, '3'})).
           to_raise 'list of numbers expected, got string at index 3'
    - it matches types:
        expect(fn('list of string', {})).not_to_raise 'any error'
        expect(fn('list of string', {'foo'})).not_to_raise 'any error'
        expect(fn('list of string', {'f', 'o', 'o'})).not_to_raise 'any error'
  - context with non-empty list:
    - it diagnonses missing types:
        expect(fn('#list', nil)).
           to_raise 'non-empty list expected, got no value'
    - it diagnoses mismatched types:
        expect(fn('#list', false)).
           to_raise 'non-empty list expected, got boolean'
        expect(fn('#list', {})).
           to_raise 'non-empty list expected, got empty list'
        expect(fn('#list', {foo=1})).
           to_raise 'non-empty list expected, got table'
        expect(fn('#list', Object)).
           to_raise 'non-empty list expected, got empty Object'
        expect(fn('#list', List {})).
           to_raise 'non-empty list expected, got empty List'
    - it matches types:
        expect(fn('#list', {1})).not_to_raise 'any error'
  - context with non-empty list of homogenous elements:
    - it diagnoses missing types:
        expect(fn('#list of boolean', nil)).
           to_raise 'non-empty list expected, got no value'
        expect(fn('#list of booleans', nil)).
           to_raise 'non-empty list expected, got no value'
    - it diagnoses mismatched types:
        expect(fn('#list of file', {})).
           to_raise 'non-empty list expected, got empty table'
        expect(fn('#list of file', io.stderr)).
           to_raise 'non-empty list expected, got file'
        expect(fn('#list of files', {file=io.stderr})).
           to_raise 'non-empty list expected, got table'
    - it diagnoses mismatched element types:
        expect(fn('#list of number', {false})).
           to_raise 'non-empty list of numbers expected, got boolean at index 1'
        expect(fn('#list of numbers', {1, 2, '3'})).
           to_raise 'non-empty list of numbers expected, got string at index 3'
    - it matches types:
        expect(fn('#list of string', {'foo'})).not_to_raise 'any error'
        expect(fn('#list of string', {'f', 'o', 'o'})).not_to_raise 'any error'
  - context with container:
    - it diagnoses missing types:
        expect(fn('List of boolean', nil)).
           to_raise 'List expected, got no value'
        expect(fn('List of booleans', nil)).
           to_raise 'List expected, got no value'
    - it diagnoses mismatched types:
        expect(fn('List of file', io.stderr)).
           to_raise 'List expected, got file'
        expect(fn('List of files', io.stderr)).
           to_raise 'List expected, got file'
        expect(fn('List of files', {file=io.stderr})).
           to_raise 'List expected, got table'
    - it diagnoses mismatched element types:
        expect(fn('List of number', List {false})).
           to_raise 'List of numbers expected, got boolean at index 1'
        expect(fn('List of numbers', List {1, 2, '3'})).
           to_raise 'List of numbers expected, got string at index 3'
    - it matches types:
        expect(fn('list of string', List {})).not_to_raise 'any error'
        expect(fn('list of string', List {'foo'})).not_to_raise 'any error'
        expect(fn('list of string', List {'f', 'o', 'o'})).not_to_raise 'any error'
  - context with object:
    - it diagnoses missing types:
        expect(fn('object', nil)).to_raise 'object expected, got no value'
        expect(fn('Object', nil)).to_raise 'Object expected, got no value'
        expect(fn('Foo', nil)).to_raise 'Foo expected, got no value'
        expect(fn('any', nil)).to_raise 'any value expected, got no value'
    - it diagnoses mismatched types:
        expect(fn('object', {0})).to_raise 'object expected, got table'
        expect(fn('Object', {0})).to_raise 'Object expected, got table'
        expect(fn('object', {_type='Object'})).to_raise 'object expected, got table'
        expect(fn('Object', {_type='Object'})).to_raise 'Object expected, got table'
        expect(fn('Object', Foo)).to_raise 'Object expected, got Foo'
        expect(fn('Foo', {0})).to_raise 'Foo expected, got table'
        expect(fn('Foo', Object)).to_raise 'Foo expected, got Object'
    - it matches types:
        expect(fn('object', Object)).not_to_raise 'any error'
        expect(fn('object', Object {})).not_to_raise 'any error'
        expect(fn('object', Foo)).not_to_raise 'any error'
        expect(fn('object', Foo {})).not_to_raise 'any error'
  - it matches anything:
      expect(fn('any', true)).not_to_raise 'any error'
      expect(fn('any', {})).not_to_raise 'any error'
      expect(fn('any', Object)).not_to_raise 'any error'
      expect(fn('any', Foo {})).not_to_raise 'any error'
  - context with a list of valid types:
    - it diagnoses missing elements:
        expect(fn('string|table', nil)).
           to_raise 'string or table expected, got no value'
        expect(fn('string|list|#table', nil)).
           to_raise 'string, list or non-empty table expected, got no value'
        expect(fn('string|number|list|object', nil)).
           to_raise 'string, number, list or object expected, got no value'
    - it diagnoses mismatched elements:
        expect(fn('string|table', false)).
           to_raise 'string or table expected, got boolean'
        expect(fn('string|#table', {})).
           to_raise 'string or non-empty table expected, got empty table'
        expect(fn('string|number|#list|object', {})).
           to_raise 'string, number, non-empty list or object expected, got empty table'
    - it matches any type from a list:
        expect(fn('string|table', 'foo')).not_to_raise 'any error'
        expect(fn('string|table', {})).not_to_raise 'any error'
        expect(fn('string|table', {0})).not_to_raise 'any error'
        expect(fn('table|table', {})).not_to_raise 'any error'
        expect(fn('#table|table', {})).not_to_raise 'any error'
  - context with an optional type element:
    - it diagnoses mismatched elements:
        expect(fn('?boolean', 'string')).
           to_raise 'boolean or nil expected, got string'
        expect(fn('?boolean|:symbol', {})).
           to_raise 'boolean, :symbol or nil expected, got empty table'
    - it matches nil against a single type:
        expect(fn('?any', nil)).not_to_raise 'any error'
        expect(fn('?boolean', nil)).not_to_raise 'any error'
        expect(fn('?string', nil)).not_to_raise 'any error'
    - it matches nil against a list of types:
        expect(fn('?boolean|table', nil)).not_to_raise 'any error'
        expect(fn('?string|table', nil)).not_to_raise 'any error'
        expect(fn('?table|#table', nil)).not_to_raise 'any error'
        expect(fn('?#table|table', nil)).not_to_raise 'any error'
    - it matches nil against a list of optional types:
        expect(fn('?boolean|?table', nil)).not_to_raise 'any error'
        expect(fn('?string|?table', nil)).not_to_raise 'any error'
        expect(fn('?table|?#table', nil)).not_to_raise 'any error'
        expect(fn('?#table|?table', nil)).not_to_raise 'any error'
    - it matches any named type:
        expect(fn('?any', false)).not_to_raise 'any error'
        expect(fn('?boolean', false)).not_to_raise 'any error'
        expect(fn('?string', 'string')).not_to_raise 'any error'
    - it matches any type from a list:
        expect(fn('?boolean|table', {})).not_to_raise 'any error'
        expect(fn('?string|table', {0})).not_to_raise 'any error'
        expect(fn('?table|#table', {})).not_to_raise 'any error'
        expect(fn('?#table|table', {})).not_to_raise 'any error'
    - it matches any type from a list with several optional specifiers:
        expect(fn('?boolean|?table', {})).not_to_raise 'any error'
        expect(fn('?string|?table', {0})).not_to_raise 'any error'
        expect(fn('?table|?table', {})).not_to_raise 'any error'
        expect(fn('?#table|?table', {})).not_to_raise 'any error'


- describe argscheck:
  - before: |
      function mkstack(name, spec)
         return string.format([[
            local argscheck = require 'typecheck'.argscheck  -- line 1
            local function caller()                          -- line 2
               argscheck('%s', function() end)               -- line 3
            end                                              -- line 4
            caller()                                         -- line 5
         ]], tostring(name), tostring(spec))
      end

      f = M.argscheck

      mkmagic = function()
         return 'MAGIC'
      end
      wrapped = f('inner()', mkmagic)

      _, badarg, badresult = init(M, '', 'inner')
      id = function(...)
         return ...
      end

  - it returns the wrapped function:
      expect(wrapped).not_to_be(inner)
      expect(wrapped()).to_be 'MAGIC'
  - it does not wrap the function when _ARGCHECK is disabled: |
      script = [[
         require 'std._debug'(false)
         local argscheck = require 'typecheck'.argscheck
         local function inner()
            return 'MAGIC'
         end
         local wrapped = argscheck('inner(?any)', inner)
         os.exit(wrapped == inner and 0 or 1)
      ]]
      expect(luaproc(script)).to_succeed()

  - context used as an annotation:
    - before:
        wrapped = f 'mkmagic()' .. mkmagic
    - it returns the wrapped function:
        expect(wrapped).not_to_be(mkmagic)
        expect(wrapped()).to_be 'MAGIC'
    - it does not wrap the function when _ARGCHECK is disabled: |
        script = [[
           require 'std._debug'(false)
           local argscheck = require 'typecheck'.argscheck
           local function inner()
              return 'MAGIC'
           end
           local wrapped = argscheck 'inner(?any)' .. inner
           os.exit(wrapped == inner and 0 or 1)
        ]]
        expect(luaproc(script)).to_succeed()

  - context when checking zero argument function:
    - it diagnoses too many arguments:
        expect(wrapped(false)).to_raise(badarg(1))
    - it accepts correct argument types:
        expect(wrapped()).to_be 'MAGIC'

  - context when checking single argument function:
    - before:
        wrapped = f('inner(#table)', mkmagic)
    - it diagnoses missing arguments:
        expect(wrapped()).to_raise(badarg(1, 'non-empty table'))
    - it diagnoses wrong argument types:
        expect(wrapped {}).to_raise(badarg(1, 'non-empty table', 'empty table'))
    - it diagnoses too many arguments:
        expect(wrapped({1}, 2, nop, '', false)).to_raise(badarg(1, 5))
    - it accepts correct argument types:
        expect(wrapped({1})).to_be 'MAGIC'

  - context when checking multi-argument function:
    - before:
        wrapped = f('inner(table, function)', mkmagic)
    - it diagnoses missing arguments:
        expect(wrapped()).to_raise(badarg(1, 'table'))
        expect(wrapped({})).to_raise(badarg(2, 'function'))
    - it diagnoses wrong argument types:
        expect(wrapped(false)).to_raise(badarg(1, 'table', 'boolean'))
        expect(wrapped({}, false)).to_raise(badarg(2, 'function', 'boolean'))
    - it diagnoses too many arguments:
        expect(wrapped({}, nop, false)).to_raise(badarg(3))
    - it accepts correct argument types:
        expect(wrapped({}, nop)).to_be 'MAGIC'

  - context when checking nil argument function:
    - before:
        wrapped = f('inner(?int, string)', mkmagic)
    - it diagnoses wrong argument types:
        expect(wrapped(false)).to_raise(badarg(1, 'int or nil', 'boolean'))
        expect(wrapped(1, false)).to_raise(badarg(2, 'string', 'boolean'))
        expect(wrapped(nil, false)).to_raise(badarg(2, 'string', 'boolean'))
    - it diagnoses too many arguments:
        expect(wrapped(1, 'foo', nop)).to_raise(badarg(3))
        expect(wrapped(nil, 'foo', nop)).to_raise(badarg(3))
    - it accepts correct argument types:
        expect(wrapped(1, 'foo')).to_be 'MAGIC'
        expect(wrapped(nil, 'foo')).to_be 'MAGIC'

  - context when checking optional multi-argument function:
    - before:
        wrapped = f('inner([int], string)', mkmagic)
    - it diagnoses missing arguments:
        expect(wrapped()).to_raise(badarg(1, 'int or string'))
        expect(wrapped(1)).to_raise(badarg(2, 'string'))
    - it diagnoses wrong argument types:
        expect(wrapped(false)).to_raise(badarg(1, 'int or string', 'boolean'))
    - it diagnoses too many arguments:
        expect(wrapped(1, 'two', nop)).to_raise(badarg(3))
    - it accepts correct argument types:
        expect(wrapped('two')).to_be 'MAGIC'
        expect(wrapped(1, 'two')).to_be 'MAGIC'

  - context when checking final optional multi-argument function:
    - before:
        wrapped = f('inner(?any, ?string, [any])', mkmagic)
    - it diagnoses wrong argument types:
        expect(wrapped(1, false)).to_raise(badarg(2, 'string or nil', 'boolean'))
        expect(wrapped(nil, false)).to_raise(badarg(2, 'string or nil', 'boolean'))
    - it diagnoses too many arguments:
        expect(wrapped(1, 'two', 3, false)).to_raise(badarg(4))
        expect(wrapped(nil, 'two', 3, false)).to_raise(badarg(4))
        expect(wrapped(1, nil, 3, false)).to_raise(badarg(4))
        expect(wrapped(nil, nil, 3, false)).to_raise(badarg(4))
    - it accepts correct argument types:
        expect(wrapped()).to_be 'MAGIC'
        expect(wrapped(1)).to_be 'MAGIC'
        expect(wrapped(nil, 'two')).to_be 'MAGIC'
        expect(wrapped(1, 'two')).to_be 'MAGIC'
        expect(wrapped(nil, nil, 3)).to_be 'MAGIC'
        expect(wrapped(1, nil, 3)).to_be 'MAGIC'
        expect(wrapped(nil, 'two', 3)).to_be 'MAGIC'
        expect(wrapped('one', 'two', 3)).to_be 'MAGIC'

  - context when checking final ellipsis function:
    - before:
        wrapped = f('inner(string, int...)', mkmagic)
    - it diagnoses missing arguments:
        expect(wrapped()).to_raise(badarg(1, 'string'))
        expect(wrapped('foo')).to_raise(badarg(2, 'int'))
    - it diagnoses wrong argument types:
        expect(wrapped(false)).to_raise(badarg(1, 'string', 'boolean'))
        expect(wrapped('foo', false)).to_raise(badarg(2, 'int', 'boolean'))
        expect(wrapped('foo', 1, false)).to_raise(badarg(3, 'int', 'boolean'))
        expect(wrapped('foo', 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, false)).
           to_raise(badarg(12, 'int', 'boolean'))
    - it accepts correct argument types:
        expect(wrapped('foo', 1)).to_be 'MAGIC'
        expect(wrapped('foo', 1, 2)).to_be 'MAGIC'
        expect(wrapped('foo', 1, 2, 5)).to_be 'MAGIC'

  - context when checking optional final parameter:
    - context with single argument:
      - before:
          wrapped = f('inner([int])', mkmagic)
      - it diagnoses wrong argument types:
          expect(wrapped(false)).to_raise(badarg(1, 'int', 'boolean'))
      - it diagnoses too many arguments:
          expect(wrapped(1, nop)).to_raise(badarg(2))
      - it accepts correct argument types:
          expect(wrapped()).to_be 'MAGIC'
          expect(wrapped(1)).to_be 'MAGIC'
    - context with trailing ellipsis:
      - before:
          wrapped = f('inner(string, [int]...)', mkmagic)
      - it diagnoses missing arguments:
          expect(wrapped()).to_raise(badarg(1, 'string'))
      - it diagnoses wrong argument types:
          expect(wrapped(false)).to_raise(badarg(1, 'string', 'boolean'))
          expect(wrapped('foo', false)).to_raise(badarg(2, 'int', 'boolean'))
          expect(wrapped('foo', 1, false)).to_raise(badarg(3, 'int', 'boolean'))
          expect(wrapped('foo', 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, false)).
             to_raise(badarg(12, 'int', 'boolean'))
      - it accepts correct argument types:
          expect(wrapped('foo')).to_be 'MAGIC'
          expect(wrapped('foo', 1)).to_be 'MAGIC'
          expect(wrapped('foo', 1, 2)).to_be 'MAGIC'
          expect(wrapped('foo', 1, 2, 5)).to_be 'MAGIC'
    - context with inner ellipsis:
      - before:
          wrapped = f('inner(string, [int...])', mkmagic)
      - it diagnoses missing arguments:
          expect(wrapped()).to_raise(badarg(1, 'string'))
      - it diagnoses wrong argument types:
          expect(wrapped(false)).to_raise(badarg(1, 'string', 'boolean'))
          expect(wrapped('foo', false)).to_raise(badarg(2, 'int', 'boolean'))
          expect(wrapped('foo', 1, false)).to_raise(badarg(3, 'int', 'boolean'))
          expect(wrapped('foo', 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, false)).
             to_raise(badarg(12, 'int', 'boolean'))
      - it accepts correct argument types:
          expect(wrapped('foo')).to_be 'MAGIC'
          expect(wrapped('foo', 1)).to_be 'MAGIC'
          expect(wrapped('foo', 1, 2)).to_be 'MAGIC'
          expect(wrapped('foo', 1, 2, 5)).to_be 'MAGIC'

  - context when omitting self type:
    - before:
        me = {
           wrapped = f('me:inner(string)', mkmagic)
        }
        _, badarg, badresult = init(M, '', 'me:inner')
    - it diagnoses missing arguments:
        expect(me:wrapped()).to_raise(badarg(1, 'string'))
    - it diagnoses wrong argument types:
        expect(me:wrapped(false)).to_raise(badarg(1, 'string', 'boolean'))
    - it diagnoses too many arguments:
        expect(me:wrapped('foo', false)).to_raise(badarg(2))
    - it accepts correct argument types:
        expect(me:wrapped('foo')).to_be 'MAGIC'

  - context with too many args:
    - before:
        wrapped = f('inner([string], int)', mkmagic)
    - it diagnoses missing arguments:
        expect(wrapped()).to_raise(badarg(1, 'string or int'))
        expect(wrapped('one')).to_raise(badarg(2, 'int'))
    - it diagnoses wrong argument types:
        expect(wrapped(false)).to_raise(badarg(1, 'string or int', 'boolean'))
        expect(wrapped('one', false)).to_raise(badarg(2, 'int', 'boolean'))
    - it diagnoses too many arguments:
        expect(wrapped('one', 2, false)).to_raise(badarg(3))
        expect(wrapped(1, false)).to_raise(badarg(2))
    - it accepts correct argument types:
        expect(wrapped(1)).to_be 'MAGIC'
        expect(wrapped('one', 2)).to_be 'MAGIC'

  - context when checking single return value function:
    - before: |
        wrapped = f('inner(?any...) => #table', id)
    - it diagnoses missing results:
        expect(wrapped()).to_raise(badresult(1, 'non-empty table'))
    - it diagnoses wrong result types:
        expect(wrapped {}).
           to_raise(badresult(1, 'non-empty table', 'empty table'))
    - it diagnoses too many results:
        expect(wrapped({1}, 2, nop, '', false)).to_raise(badresult(1, 5))
    - it accepts correct results:
        expect({wrapped {1}}).to_equal {{1}}

  - context with variant single return value function:
    - before:
        wrapped = f('inner(?any...) => int or nil', id)
    - it diagnoses wrong result types:
        expect(wrapped(false)).to_raise(badresult(1, 'int or nil', 'boolean'))
    - it diagnoses too many results:
        expect(wrapped(1, nop)).to_raise(badresult(2))
    - it accepts correct result types:
        expect({wrapped()}).to_equal {}
        expect({wrapped(1)}).to_equal {1}

  - context when checking multi-return value function:
    - before:
        wrapped = f('inner(?any...) => int, string', id)
    - it diagnoses missing results:
        expect(wrapped()).to_raise(badresult(1, 'int'))
        expect(wrapped(1)).to_raise(badresult(2, 'string'))
    - it diagnoses wrong result types:
        expect(wrapped(false)).to_raise(badresult(1, 'int', 'boolean'))
        expect(wrapped(1, false)).to_raise(badresult(2, 'string', 'boolean'))
    - it diagnoses too many results:
        expect(wrapped(1, 'two', false)).to_raise(badresult(3))
    - it accepts correct argument types:
        expect({wrapped(1, 'two')}).to_equal {1, 'two'}

  - context when checking nil return specifier:
    - before:
        wrapped = f('inner(?any...) => ?int, string', id)
    - it diagnoses wrong result types:
        expect(wrapped(false)).to_raise(badresult(1, 'int or nil', 'boolean'))
        expect(wrapped(1, false)).to_raise(badresult(2, 'string', 'boolean'))
        expect(wrapped(nil, false)).to_raise(badresult(2, 'string', 'boolean'))
    - it diagnoses too many results:
        expect(wrapped(1, 'foo', nop)).to_raise(badresult(3))
        expect(wrapped(nil, 'foo', nop)).to_raise(badresult(3))
    - it accepts correct result types:
        expect({wrapped(1, 'foo')}).to_equal {1, 'foo'}
        expect({wrapped(nil, 'foo')}).to_equal {[2] = 'foo'}

  - context when checking variant multi-return value function:
    - before:
        wrapped = f('inner(?any...) => int, string or string', id)
    - it diagnoses missing results:
        expect(wrapped()).to_raise(badresult(1, 'int or string'))
        expect(wrapped(1)).to_raise(badresult(2, 'string'))
    - it diagnoses wrong result types:
        expect(wrapped(false)).to_raise(badresult(1, 'int or string', 'boolean'))
    - it diagnoses too many results:
        expect(wrapped(1, 'two', nop)).to_raise(badresult(3))
    - it accepts correct result types:
        expect({wrapped('two')}).to_equal {'two'}
        expect({wrapped(1, 'two')}).to_equal {1, 'two'}

  - context when checking variant nil,errmsg pattern function:
    - before:
        wrapped = f('inner(?any...) => int, string or nil, string', id)
    - it diagnoses missing results:
        expect(wrapped()).to_raise(badresult(2, 'string'))
        expect(wrapped(1)).to_raise(badresult(2, 'string'))
    - it diagnoses wrong result types:
        expect(wrapped(false)).to_raise(badresult(1, 'int or nil', 'boolean'))
        expect(wrapped(1, false)).to_raise(badresult(2, 'string', 'boolean'))
    - it diagnoses too many results:
        expect(wrapped(1, 'two', nop)).to_raise(badresult(3))
        expect(wrapped(nil, 'errmsg', nop)).to_raise(badresult(3))
    - it accepts correct result types:
        expect({wrapped(1, 'two')}).to_equal {1, 'two'}
        expect({wrapped(nil, 'errmsg')}).to_equal {[2] = 'errmsg'}

  - context when checking optional multi-return value function:
    - before:
        wrapped = f('inner(?any...) => [int], string', id)
    - it diagnoses missing results:
        expect(wrapped()).to_raise(badresult(1, 'int or string'))
        expect(wrapped(1)).to_raise(badresult(2, 'string'))
    - it diagnoses wrong result types:
        expect(wrapped(false)).to_raise(badresult(1, 'int or string', 'boolean'))
    - it diagnoses too many results:
        expect(wrapped(1, 'two', nop)).to_raise(badresult(3))
    - it accepts correct result types:
        expect({wrapped('two')}).to_equal {'two'}
        expect({wrapped(1, 'two')}).to_equal {1, 'two'}

  - context when checking final optional multi-return value function:
    - before:
        wrapped = f('inner(?any...) => ?any, ?string, [any]', id)
    - it diagnoses wrong result types:
        expect(wrapped(1, false)).to_raise(badresult(2, 'string or nil', 'boolean'))
        expect(wrapped(nil, false)).to_raise(badresult(2, 'string or nil', 'boolean'))
    - it diagnoses too many results:
        expect(wrapped(1, 'two', 3, false)).to_raise(badresult(4))
        expect(wrapped(nil, 'two', 3, false)).to_raise(badresult(4))
        expect(wrapped(1, nil, 3, false)).to_raise(badresult(4))
        expect(wrapped(nil, nil, 3, false)).to_raise(badresult(4))
    - it accepts correct result types:
        expect({wrapped()}).to_equal {}
        expect({wrapped(1)}).to_equal {1}
        expect({wrapped(nil, 'two')}).to_equal {[2]='two'}
        expect({wrapped(1, 'two')}).to_equal {1, 'two'}
        expect({wrapped(nil, nil, 3)}).to_equal {[3]=3}
        expect({wrapped(1, nil, 3)}).to_equal {1, [3]=3}
        expect({wrapped(nil, 'two', 3)}).to_equal {[2]='two', [3]=3}
        expect({wrapped('one', 'two', 3)}).to_equal {'one', 'two', 3}

  - context when checking optional final result:
    - context with single result:
      - before:
          wrapped = f('inner(?any...) => [int]', id)
      - it diagnoses wrong result types:
          expect(wrapped(false)).to_raise(badresult(1, 'int', 'boolean'))
      - it diagnoses too many results:
          expect(wrapped(1, nop)).to_raise(badresult(2))
      - it accepts correct result types:
          expect({wrapped()}).to_equal {}
          expect({wrapped(1)}).to_equal {1}
    - context with trailing ellipsis:
      - before:
          wrapped = f('inner(?any...) => string, [int]...', id)
      - it diagnoses missing results:
          expect(wrapped()).to_raise(badresult(1, 'string'))
      - it diagnoses wrong result types:
          expect(wrapped(false)).to_raise(badresult(1, 'string', 'boolean'))
          expect(wrapped('foo', false)).to_raise(badresult(2, 'int', 'boolean'))
          expect(wrapped('foo', 1, false)).to_raise(badresult(3, 'int', 'boolean'))
          expect(wrapped('foo', 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, false)).
             to_raise(badresult(12, 'int', 'boolean'))
      - it accepts correct result types:
          expect({wrapped('foo')}).to_equal {'foo'}
          expect({wrapped('foo', 1)}).to_equal {'foo', 1}
          expect({wrapped('foo', 1, 2)}).to_equal {'foo', 1, 2}
          expect({wrapped('foo', 1, 2, 5)}).to_equal {'foo', 1, 2, 5}
    - context with inner ellipsis:
      - before:
          wrapped = f('inner(?any...) => string, [int...]', id)
      - it diagnoses missing results:
          expect(wrapped()).to_raise(badresult(1, 'string'))
      - it diagnoses wrong result types:
          expect(wrapped(false)).to_raise(badresult(1, 'string', 'boolean'))
          expect(wrapped('foo', false)).to_raise(badresult(2, 'int', 'boolean'))
          expect(wrapped('foo', 1, false)).to_raise(badresult(3, 'int', 'boolean'))
          expect(wrapped('foo', 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, false)).
            to_raise(badresult(12, 'int', 'boolean'))
      - it accepts correct result types:
          expect({wrapped('foo')}).to_equal {'foo'}
          expect({wrapped('foo', 1)}).to_equal {'foo', 1}
          expect({wrapped('foo', 1, 2)}).to_equal {'foo', 1, 2}
          expect({wrapped('foo', 1, 2, 5)}).to_equal {'foo', 1, 2, 5}

  - context with too many results:
    - before:
        wrapped = f('inner(?any...) => [string], int', id)
    - it diagnoses missing results:
        expect(wrapped()).to_raise(badresult(1, 'string or int'))
        expect(wrapped 'one').to_raise(badresult(2, 'int'))
    - it diagnoses wrong result types:
        expect(wrapped(false)).
           to_raise(badresult(1, 'string or int', 'boolean'))
        expect(wrapped('one', false)).
           to_raise(badresult(2, 'int', 'boolean'))
    - it diagnoses too many results:
        expect(wrapped('one', 2, false)).to_raise(badresult(3))
        expect(wrapped(1, false)).to_raise(badresult(2))
    - it accepts correct argument types:
        expect({wrapped(1)}).to_equal {1}
        expect({wrapped('one', 2)}).to_equal {'one', 2}


- describe extramsg_mismatch:
  - before:
      f = M.extramsg_mismatch

  - it returns the expected types:
      expect(f 'nil').to_contain 'nil expected, '
      expect(f 'bool').to_contain 'boolean expected, '
      expect(f '?bool').to_contain 'boolean or nil expected, '
      expect(f 'string|table').to_contain 'string or table expected, '
  - it returns expected container types:
      expect(f('table of int', nil, 1)).to_contain 'table of ints expected, '
      expect(f('table of int|bool', nil, 1)).
         to_contain 'table of ints or booleans expected, '
      expect(f('table of int|bool|string', nil, 1)).
         to_contain 'table of ints, booleans or strings expected, '
      expect(f('table of int|bool|string|table', nil, 1)).
         to_contain 'table of ints, booleans, strings or tables expected, '
  - it returns the actual type:
      expect(f('int')).to_contain ', got no value'
      expect(f('int', false)).to_contain ', got boolean'
      expect(f('int', {})).to_contain ', got empty table'
  - it returns table field type:
      expect(f('table of int', nil, 1)).to_contain ', got no value at index 1'
      expect(f('table of int', 'two', 2)).to_contain ', got string at index 2'
      expect(f('table of int|bool', 'five', 3)).to_contain ', got string at index 3'


- describe extramsg_toomany:
  - before:
      f = M.extramsg_toomany

  - it returns the expected thing:
      expect(f('mojo', 1, 2)).to_contain 'no more than 1 mojo'
  - it uses singular thing when 1 is expected:
      expect(f('argument', 1, 2)).to_contain 'no more than 1 argument'
  - it uses plural thing otherwise:
      expect(f('thing', 0, 3)).to_contain 'no more than 0 things'
      expect(f('result', 2, 3)).to_contain 'no more than 2 results'
  - it returns the actual count:
      expect(f('bad', 0, 1)).to_contain ', got 1'
      expect(f('bad', 99, 999)).to_contain ', got 999'
